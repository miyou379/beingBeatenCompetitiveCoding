[2024/04/30]()
LeetCode #2798 (Number of employees who met the target | 每日一题) count_if 函数免排序, 多用迭代器少用索引, lambda 表达式捕获列表不一定要填 &, 可以直接填要捕获什么变量

[2024/04/29]()
LeetCode #1329 (Sort the matrix diagonally) 本质模拟, 中间过程排序可以使用冒泡实现, 但是除了节省代码量之外优点并不明显

[2024/04/28]()
Nowcoder 月赛92::B (采矿时间到!, 贪心) 注意对于第 2 行和第 4 行来说, 往深了挖和继续挖浅的是等价的;  
Nowcoder 月赛92::C (耕种时间到) 这里满足加法原理, 且 x 以下的等级对 x 并没有贡献, 所以既可以模拟收割 (队列层次遍历), 也可以对每颗种子的后代进行统计, 还可以直接模拟一颗种子就是一片田, 这里可以用到之前的假设模拟轮数的技巧, 这里每颗种子一定不会超过 20 轮, 能大幅缩减代码量, 另外写浮点运算的时候一定记得 *1.0;  
LeetCode #1017 (Convert to base -2 | 每日一题) 这题最大的坑点是 -2 会导致你的余数可能确定不了是加还是减, 但是对于任意一个数 x 都可以按照 s += x%base; x -= x%base; x /= base 的方法来转换, 需要注意这里的余数被限制在 0/1 这个范围内, 所以可以用位运算 a&1 来取最低位的余数 (之所以能这样干是因为补码表示法中取负的奇偶性并不发生改变), 需要多加理解

[2024/04/27]()
AtCoder ABC351::C (Merge the balls) 简单模拟题别想着和题目作对浪费时间;  
AtCoder ABC351::E (Double Sum) SUM = Sigma(i=1, n)Sigma(j=i, n) max(Aj-Ai, 0) = Sigma(i=1, n) (i-1)*Ai - Sigma(i=1, n) (i-1)*Bi, 其中 Bi 为降序排序后第 i 个元素, 待证明;  
LeetCode #3 (Longest substring without repeating characters) 滑动窗口题, 如果说出现过则清空原记录, 一直 pop 到没有重复的为止, 用变量记录最大窗口长度, 滑动窗口 / 单调队列可以复习下 Luogu P1886;  
LeetCode #2639 (Find the width of columns of a grid | 每日一题) 水。

[2024/04/26]()
LeetCode #1146 (Snapshot Array) 第一次写真正的类, 实际上写起来跟结构体是一样的, 这题里面验证了速度 upper_bound > iterator > array[index] 同时学习了 prev(iter) 和 next(iter), emplace_back 挺好用的

[2024/04/25]()
201 (Squares | ch4), 10976 (Fractions Again?!), 11059 (Maximum Product | ch7), 524 (Prime Ring Problem, 回溯 | ch7), 725 (Division | ch7)  
201 注意对于每个点的判断条件, 其中从 point(x, y) 出发横向和纵向的边是可以每次只判断一次的, 并且结束判断也是依靠这两条边, 而另外两条边必须每次都进行判断;  
10976 暴力解的约束性问题, 这里可以由题目的不等式得到 y <= 2k, 并根据这个条件依次枚举情况求解;  
11059 数据量小, 暴力枚举边界即可;  
524 next_permutation() 虽然很快, 但是也快不过极大量的可能情况, 考虑使用回溯法, 需要注意的是如果对 vector 预先分配了内存, 使用时一定要注意 next_permutation() 和 sort() 这些操作的范围;  
725 暴力枚举, 确定一个就能确定另外一个, 同时注意到分母大于等于分子来缩小范围;  
LeetCode #24 (Swap nodes in pairs) 遇到了超级大坑指针引用, 注意引用和指针的捕获方式, 具体描述在 CAAC 资料群进行了猜测并证实, 这里不再赘述, 在不必要时避免使用指针引用;  
LeetCode #2739 (Total distance traveled | 每日一题) 水得不想写进来了。

[2024/04/23]()
LeetCode #13 (Roman to Integer) 用 DFS / 递归重写了一遍, 效率会比一遍遍历要低一点, 用到了 #define 来减少输入量, 另外注意类中初始化需要显示调用构造函数, 若要修改字典的值, 只能单独写一个 init() 函数来修改, 类里面只能写声明和初始化;  
LeetCode #1052 (Grumpy bookstore owner) 这题其实暴力写就行, 每次扫描长度为 minutes 的区间, 并记录修改值 (题目求最大的满意数就是最大的 Delta 值), 但实际上都已经想到固定长度区间了就可以直接用 SlidingWindow, 这里没必要用队列保存, 直接拿变量记录没发动技能的 sum 和发动后的 sum 即可, 这里写的时候有个小技巧是前 0~n-1 个数可以先单独处理, 避免在循环里面又要写条件判断减慢速度

[2024/04/22]()
AtCoder ABC350::E (Toward 0, 数学期望, DP, DFS+记忆化搜索) 有一个非常明显的 "状态转移过程", 考虑用 DP, DP 的本质就是存点什么东西, 保证无后效性的最优子问题的最优解, 这里对于支付 x yen 的情况, 当前的钱就是 ans1=x+f(n/A), 而对于支付 y yen 的情况, 当骰子为 1 时回到现在永远出不去, 为了避免成环直接跳过 1 的情况, 相应的代价应该变为 1.2y yen, 而对于 [2,3,4,5,6] 五种情况都是可以正常向下推的, 当前的钱就应该是 ans2=1.2y+f(n/i), 对于初始情况, 初始情况就是最终 towards 0 的情况, 消耗 0 yen, 状态转移为 dp[n]=min(ans1,ans2), 另外 dp[i] 不为空时应该读取 dp[i] 的值 (记忆化);  
LeetCode #53 (Maximum subarray, DP, 递推+记忆化搜索) 很经典的一道 DP, 或者说是背包 DP, 这里对于每个 dp[i], 代表的是以他结尾的目前极大的连续子区间和 (注意是极大不是最大), 把他加上 / 另起炉灶, 则状态转移方程为: dp[i]=max(dp[i-1]+nums[i],nums[i]), 初始状态为 dp[0]=nums[0], 由于并不保证全局最大, 这里必须要设置全局变量 maxi=nums[0] 用来记录全局最大值, 每次转移进行替换;  
LeetCode #377 (Combination sum IV, 背包 DP, DFS+记忆化搜索 | 每日一题) 对于 dp[i], 状态转移可能从 dp[i-num] 转移过来 (index 不为负), 这里每种情况都是一种排列方式, 所以状态转移方程为 dp[i]+=dp[i-num] for num in nums, 其初始状态为 dp[0]=1, 代表从 0 到 num 只有一种情况。这里注意一个问题是, 题目虽然保证了最终的结果 dp[target] 在 int32 范围内, 但是实际上在 dp 过程中, 有一些状态最终是无法到达 dp[target] 的, 但是他们可能溢出, 所以选用 uint32 保存。这实际上也启发我们, DP 实际上是一个自下而上的过程, 极有可能产生很多不相关的值, 而 DFS+记忆化搜索是自上而下的过程, 能够最大程度的减少不需要的运算

[2024/04/21]()
679 (Dropping Balls, 分治), 540 (Team Queue, 队列), 12657 (Boxes in a Line, 双向链表, 优化)  
679 用到了分治的思想, 对于以某个节点作为根节点的子树, 往左走和往右走的小球是一定不会相交的, 并且可以得出往左是奇数个, 往右是偶数个的简单结论, 非常精妙;  
540 用了一个主队列用来维护团队信息, 队列数组来维护各个团队的信息, 考察对队列的掌握情况, 同时记住队列和栈没有 iterator, 这里有一个提示信息是队伍编号**连续且范围较小**, 所以才能用队列数组维护每个团队的信息, 若不连续可以用 map, 范围较小是关键所在;  
12657 史诗级坑题, 首先要强调一点: make_tuple 搭配 tie 的多元赋值非常消耗时间 (0.080s -> TLE), 因为每次都需要调用 tuple 构造函数还需要解包, 能不用就尽量不用; 双向链表节点之间的连接很明显是重复的工作, 借助函数来完成, 不要强行手写把自己头都搞昏了; 这题有一个优化点是 reverse, 我利用二维数组加 rvs 标记来完成了这个工作, 实际效率还行 (每次访问都需要先访问 rvs 变量), 主要是写起来也并不方便, 这里可以发现反转后并不对答案造成影响 (奇数个), 偶数个时直接用总和减求出来的 ans 即可; 仔细读题, 特别是这种样例比较全的题一定要先看清楚怎么操作的;  
LeetCode #216 (Combination sum III, DFS | 每日一题) 一维情形 DFS, 比昨天的还简单。。。这里注意 tmp 这个 vector 可以用 push_back() 和 pop_back() 来 "标记" 访问过没有, 不需要每次都去新开一个新 vector 浪费内存, 说到根本时因为仍是单线程应用

[2024/04/20]()
LeetCode #39 (Combination sum, DFS | 每日一题) 一维情形的简单 DFS, 注意能剪枝就剪点, 另外不要少了 DFS 的各个情况;  
AtCoder ABC350::C (Sort, 哈希表) 这个题的排序方式实际上就是把每个数字尽快归位, 直接把他与应该在这个位置的那个位置的元素相交换, 这个方法得到的交换次数一定是在 [0, N-1] 这个区间的, 同时, 这也是通过交换元素的方法得到有序序列的最快方法 (牛客浙江机电职业技术学院第八届新生亮相赛 C 题, 数列排序), 你问我为什么快排比这个慢? 因为这玩意本身就需要一个有序数组来辅助（;  
AtCoder ABC350::D (New Friends, 并查集) 掌握并查集模板, 特别是要熟悉压缩查找 (每次只能压缩一层) 和按秩合并 (简单的合并到复杂的里面) 的写法, 同时这个题也引出了数据溢出的问题, 对于乘法溢出, 唯一的解决方法是对表达式中的因子进行类型转换让他去自动推导 (任意位置的都可以), 对整个表达式转换和赋值到临时变量没用, 同时此题使用 unordered_map 内存占用明显大于数组, 接近两倍;  
待补题: 天梯赛::L1-101 (别再来这么多猫娘了！), 天梯赛::L2-051 (满树的遍历), 天梯赛::L2-052 (吉利矩阵)

[2024/04/19]()
LeetCode #455 (Assign Cookies, 贪心), 对于每块饼干来说, 找到第一个刚好能够满足他的小朋友是最优策略; 对于每个小朋友来说, 找到第一块刚好能够满足他的饼干是最佳策略, 两者等价, 在操作前先排序, 排序后的小朋友胃口越来越大, 饼干也越来越大, 所以可以借助双指针, 不需要回去搜索已经扫过的地方;  
LeetCode #13 (Roman to Integer, 哈希表), 这题最坑的地方在于罗马数字前面的减法最多只能有一个同样的字符!!!! 比如 IIX 这种是非法输入, 输在常识了(悲), 直接从前往后扫, 遇到小于后面一个字符的就减, 否则就加

[2024/04/18]()
1587 (Box | ch3), 1588 (Kick Down | ch3)  
1587 用到了自定义类来拓展 std::map, 如果不这么麻烦只需要保存 pair 然后排序之后看是不是首尾相接就行;  
1588 比较坑的点在于上下的两块板子并不是像题目说的不能交换, 当然是可以交换的且对答案没影响, 重要的是如果不进行交换, 按照我自己写的 move() 函数来进行判定的话, 实际上只是把 a 板向右移, 无法考虑到向左移的情况, 所以要交换两块板子再来一次;  
LeetCode #2007 (Find original array from doubled array, 哈希表, 贪心 | 每日一题), 首先可以想到原数组的元素一定是小于对应的双倍数组的, 即需要先进行一次排序, 排序后, 由于每个元素可能会出现多次, 所以不能用 <int, bool> 的形式, 当遇到当前元素需要找他的对应双倍时, 若找到其双倍则证明该数为原数组, 若原数已经不存在了 (cnt[p] == 0) 则证明该数已经被放到 doubled array 里面了, 如果以上两种情况都不满足则证明出错; 对于哈希表, 这里既可以采用 map, 但是其查找的平均时间复杂度为 O(log n), 鉴于本题的数据量较小, 可以直接用一维数组当哈希表, 但是要注意越界判断, p > 2e4 时不可能还有其双倍在数组中, 直接返回;  
LeetCode #2 (Add two numbers, 链表), 简单题, 注意条件判断就能写得很优雅, 可以尝试写一下不创建新链表的做法;  
LeetCode #409 (Longest Palindrome, 贪心), 注意到这里是取出来, 不一定要取完, 把偶数个数的全部取完然后奇数个数的取 n-1 个, 最终再 ans+1 代表奇数个中取一个, 特判是没有奇数个

[2024/04/17]()
11988 (Broken Keyboard, 双向链表 | ch6), 122 (Trees on the level, 层次遍历 | ch6), 442 (Matrix Chain Multiplication, 栈处理简单表达式 | ch6), 514 (Rails, 栈模拟 | ch6)  
11988 可以用双向链表也可以用 std::deque;  
122 其实挺简单的, 注意保存答案统一输出, 另外, 指针引用传参才能够修改指针本身的值, 输入可以用 cin + std::string 实现;  
442 这题能够用一个栈做的最主要原因是每两个矩阵的前后是必定有括号的, 如果是普通的表达式则需先转成后缀表达式再进行处理, 另外注意栈 pop 时的元素顺序;  
514 要重点理解, 看了两遍答案都有点朦朦呼呼的, 这里模拟两个站台和一个 stack 的操作, 重点在于 A 变量既代表 A 的元素个数, 又是等于序号的, 而 B 变量只代表元素的个数, 因此, 只有在 A->C->B 和 C->B 这两个操作的时候才去修改 B 的值, 而我们要的下一个 target 也一定是 target[B], 只有在 s.top() == target[B] 时才弹出;  
LeetCode #1 (Two sum, 哈希表) 注意到题目中的数据一定是成对存在的, 则对于成对的元素理应是地位相同的, 无须进行排序, 用哈希表存储并搜索 target-nums[i] 即可;  
LeetCode #26 (Remove duplicates from sorted array) 用 std::unique(), tmp 比较法, map + erase, set 直接查重, 双指针都写了一遍, 其中最好的办法是双指针, 但要注意快指针初始状态时可以直接设为 1, 慢指针为 0, 若都为 0 则 nums[0] 恒等于 nums[0]

[2024/04/15]()
又因为打蓝桥杯打 maimai 各种各样的事情拖得没做题。。。1592 (Database | ch5)  
1592 这题充分展现了暴力思维的应用方法, 题目限制 9s, 这里直接用三重循环就解决了, 另外注意这题中 map<elemType, int> + 全局计数器uniqueNum 结合来确定 uid 的方法, 这里不能用 map<elemType, bool> 是因为实际上后面用了这个 map 的值来给 db[i][j] 赋值, 如果出现过, 则直接使用原来的 uid, map 不光是判断有没有出现过还有记录 uid 的作用, 还有注意一下变量命名的可读性。。。

[2024/04/11]()
4/11 的下午场, 10340 (All in All | ch3), 202 (Repeating Decimals | ch3), 232 (Crossword Answers | ch3), 12108 (Extraoridinarily Tired Students | ch4), 673 (Parentheses Balance | ch6)  
10340 用栈轻松解决;  
202 超级毒瘤题, 这里要注意到一点是: 对于一个有理数来说, 每次参与当次除法的分母是不相同的, 如果说分母一旦出现了两次, 那就证明这个分母前一次出现的位置到现在的位置是它的最小周期, 为什么不能够直接把十分位当作是周期的起始位置, 因为还有类似于 4.031111... 这样的有理数, 另外, 对字符串使用 erase, size 等依赖于 pos 的函数时要注意和 +=, append 这类操作的先后顺序;  
12108 展示了一个问题: 把当日的结果放到下一日在结算永远不是最好的解决方案, 能在当日清算的数据一定要在当个循环处理掉, 否则可能出现各种意料不到的 bug;  
673 栈的基础应用

[2024/04/11]()
1583 (Digit Generator | ch3), 1584 (Circular Sequence | ch3), 401 (Palindromes | ch3), 455 (Periodic Strings | ch3)  
1583 如果用 char[] 则用 atoi(), 用 std::string 则用 stoi, stol, stoll 等等;  
1584 注意 strcpy(dest, src) 的用法; 401 还是之前说的可以用一维数组来存, 仔细读题;  
455 注意到周期一定是整数个, 先排除一遍可能的最小周期可以大大降低难度;  
Luogu P1003 (铺地毯 | NOIP2011 提高组) 这题注意遍历方向和时间复杂度, 存完所有地毯信息后从后往前遍历就搜索到了, 存图会直接爆掉

[2024/04/07]()
136 (Ugly Numbers | ch5)  
136 一道优先队列, 注意优先队列的效率是远远高于 vector + 每次都排序的, 另外写 ull 和 ll 的时候一定要注意自己用模板函数里面写的什么数据类型, 因为这个卡了几个小时（

[2024/04/04]()
10082 (WERTYU | ch3), 12412 (师兄帮帮忙 | ch4)  
10082 这个题其实可以学一下 rujia 大神的处理方法, 就用一维的数组存就行, 写 map expr 太费时费力;  
12412 是花了三天肝出来的题目, debug 了长达接近四个小时, 就因为一个小小的排序问题, 排名降序就一定降序排序, 升序就一定升序排序, 血的教训。另外注意不要滥用 STL, rujia 的书上说到这里的 rank 可以不用排序算法做, 有空可以看看

[2024/04/02]()
272 (TEX Quotes | ch3), 133 (The Dole Queue, 双指针, 模拟 | ch4), 1339 (Ancient Cipher | ch4), 489 (Hangman Judge | ch4)  
272 数据给得太简单了, 根本没有复杂情况;  
133 里面用一个比较巧妙的方式计算了循环链表的下一个位置;  
1339 考虑题目中变换的性质, 答案就是字典的思想;  
489 注意题目给的数据, 可能不是等到最后再来处理, 特别是这种及时性的游戏题目

[2024/04/01]()
10815 (Andy's First Dictionary, 集合 | ch5), 101 (The Blocks Problem, 模拟 | ch5)  
101 这题写了三四个小时，充分展现了读题的重要性, 另外, 101 我自己写了个输入, 纯粹是没有掌握 cin 的方便之处, 利用 while(cin >> n) 的方式可以很轻松的处理这种多行数据;  
156 (Ananagrams, multiset) 这题充分展现了 multiset+set 的强大之处，and 要仔细读题

[2024/03/28]()
10474 (Where is the marble? | ch5), 1594 (Ducci Sequence | ch5), 两个都是 STL 的简单应用 (第五章)

[2024/03/27]()
确定要开始打 ICPC 了, 同时也为蓝桥杯和天梯赛做准备, 今日提交 400 (Unix ls | ch5)  
400 注意换行符的作用范围, 这题因为换行的地方写错了卡了一两个小时, 该省不该省的不要乱搞

[2024/02/24]()
提交了 1368 (DNA Consensus String, 字典序 | ch3)  
1368 字符串的排序问题, 寒假感冒两个月，断档了, 顺便更新了一下模板

[2023/12/15]()
今日提交 227 (Puzzle, 模拟 | ch3)

[2023/12/10]()
First commit! 今日提交了 1225 (Digit Counting | ch3), 1585 (Score | ch3), 1586 (Molar mass | ch3), 三道很基础的字符串题目, 实际上这三题应该都是暑假做的了（  
1225 用到了 to_string() 函数;  
1586 可以考虑用 enum 重写一下

[2023/12/09]()
更新 README.md

# This file is presented in flashback.
